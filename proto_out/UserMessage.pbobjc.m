// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserMessage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "UserMessage.pbobjc.h"
#import "InfoMessage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Info);
GPBObjCClassDeclaration(MsgChatContent);
GPBObjCClassDeclaration(MsgUser);

#pragma mark - UserMessageRoot

@implementation UserMessageRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - UserMessageRoot_FileDescriptor

static GPBFileDescriptor *UserMessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.messages.UserMessage"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - HeartbeatConnectReq_0

@implementation HeartbeatConnectReq_0


typedef struct HeartbeatConnectReq_0__storage_ {
  uint32_t _has_storage_[1];
} HeartbeatConnectReq_0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HeartbeatConnectReq_0 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(HeartbeatConnectReq_0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HeartbeatConnectResp_0

@implementation HeartbeatConnectResp_0

@dynamic serverTime;

typedef struct HeartbeatConnectResp_0__storage_ {
  uint32_t _has_storage_[1];
  int64_t serverTime;
} HeartbeatConnectResp_0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverTime",
        .dataTypeSpecific.clazz = Nil,
        .number = HeartbeatConnectResp_0_FieldNumber_ServerTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HeartbeatConnectResp_0__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HeartbeatConnectResp_0 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HeartbeatConnectResp_0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseClientResp_1

@implementation CloseClientResp_1

@dynamic hasInfo, info;

typedef struct CloseClientResp_1__storage_ {
  uint32_t _has_storage_[1];
  Info *info;
} CloseClientResp_1__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(Info),
        .number = CloseClientResp_1_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseClientResp_1__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseClientResp_1 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseClientResp_1__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InfoResp_2

@implementation InfoResp_2

@dynamic hasInfo, info;

typedef struct InfoResp_2__storage_ {
  uint32_t _has_storage_[1];
  Info *info;
} InfoResp_2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(Info),
        .number = InfoResp_2_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InfoResp_2__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InfoResp_2 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InfoResp_2__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginReq_1001

@implementation LoginReq_1001

@dynamic token;

typedef struct LoginReq_1001__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} LoginReq_1001__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = LoginReq_1001_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginReq_1001__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginReq_1001 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginReq_1001__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginResp_1001

@implementation LoginResp_1001

@dynamic hasMsgUser, msgUser;

typedef struct LoginResp_1001__storage_ {
  uint32_t _has_storage_[1];
  MsgUser *msgUser;
} LoginResp_1001__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgUser",
        .dataTypeSpecific.clazz = GPBObjCClass(MsgUser),
        .number = LoginResp_1001_FieldNumber_MsgUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginResp_1001__storage_, msgUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginResp_1001 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginResp_1001__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendChatReq_1002

@implementation SendChatReq_1002

@dynamic content;
@dynamic gameId;

typedef struct SendChatReq_1002__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  int64_t gameId;
} SendChatReq_1002__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChatReq_1002_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendChatReq_1002__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChatReq_1002_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendChatReq_1002__storage_, gameId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendChatReq_1002 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendChatReq_1002__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendChatResp_1002

@implementation SendChatResp_1002

@dynamic msgChatContentArray, msgChatContentArray_Count;

typedef struct SendChatResp_1002__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgChatContentArray;
} SendChatResp_1002__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgChatContentArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MsgChatContent),
        .number = SendChatResp_1002_FieldNumber_MsgChatContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendChatResp_1002__storage_, msgChatContentArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendChatResp_1002 class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendChatResp_1002__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000msgChatContent\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgUser

@implementation MsgUser

@dynamic token;
@dynamic name;
@dynamic img;

typedef struct MsgUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *name;
  NSString *img;
} MsgUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgUser_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgUser__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgUser_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgUser__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgUser_FieldNumber_Img,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgUser__storage_, img),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgUser class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgChatContent

@implementation MsgChatContent

@dynamic fromUserName;
@dynamic fromUserImg;
@dynamic fromTime;
@dynamic content;
@dynamic gameId;

typedef struct MsgChatContent__storage_ {
  uint32_t _has_storage_[1];
  NSString *fromUserName;
  NSString *fromUserImg;
  NSString *content;
  int64_t fromTime;
  int64_t gameId;
} MsgChatContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserName",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgChatContent_FieldNumber_FromUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgChatContent__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromUserImg",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgChatContent_FieldNumber_FromUserImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgChatContent__storage_, fromUserImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgChatContent_FieldNumber_FromTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgChatContent__storage_, fromTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgChatContent_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgChatContent__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgChatContent_FieldNumber_GameId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MsgChatContent__storage_, gameId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgChatContent class]
                                     rootClass:[UserMessageRoot class]
                                          file:UserMessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgChatContent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\014\000\002\013\000\003\010\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
